---
layout: page
title: 'CSS-препроцессоры'
permalink: /preprocessors/

links:
 - name: 'Миксины'
   url: '#mixins'
 - name: 'Переменные'
   url: '#variables'
 - name: 'Медиавыражения'
   url: '#mediaqueries'

additional_links:
 - name: 'CSS‑препроцессоры: переменные с цветами'
   url: 'http://nicothin.pro/page/preprocessor-color-functions'
 - name: 'Sass, LESS, Stylus, PostCSS...'
   url: 'http://nicothin.github.io/idiomatic-pre-CSS/#pre-css'
---

<p>CSS-препроцессоры — это замечательные инструменты, которые позволяют писать код проще и быстрее. Но следует понимать, что само по себе использование препроцессоров не сделает ваш код лучше, и даже более того, если до препроцессоров код был так себе, их применение может сделать его ещё хуже. Несмотря на все прекрасные возможности, которые дают препроцессоры, вам всё ещё придется самостоятельно поддерживать ваш код аккуратным и продумывать его структуру.</p>

<p>Главное правило при работе с препроцессорами — ваши переменные и миксины не должны превращаться в черный ящик. Вы всегда должны понимать что хранится в переменной и что возвращает миксин.</p>

<p>Почему это важно? Потому что проект должно быть удобно не столько писать, сколько читать. Если вы передадите проект другому разработчику, сколько ему потребуется времени, чтобы разобраться в нём? Разберётесь ли вы сами в своём проекте через полгода? Чем меньше в коде чёрных ящиков и неочевидных мест, тем меньше времени вы потратите на въезжание в проект и тем быстрее вы сможете начать решать свои задачи. Поэтому как бы ни было весело придумывать хитрые ходы и навороченные функции и миксины, помните о том, что в какой-то момент вам, возможно, придется разбираться в этом коде заново.</p>

<p>Если очень хочется заняться программированием на препроцессорах, заведите себе аккаунт на <a href="http://codepen.io/">Codepen</a> и играйтесь там безо всяких ограничений. Экспериментировать с кодом не только интересно, но и полезно, и вы легко сможете поделиться своими экспериментами с миром публикуя ссылки на онлайн-демки, но в коде сайтов, которые вам предстоит поддерживать, делать навороченные конструкции лучше не стоит.</p>

<p>И переменные и миксины должны создаваться для значений и кодов, которые планируется потом многократно использовать. Если переменная или миксин используются в коде ровно один раз, они, скорее всего, не нужны.</p>

<ol>
  <li>
    <h3 id="mixins">Миксины</h3>

    <p>В миксины удобно класть простой и часто повторяющийся код. Например, clearfix или сброс стилей списков.</p>

    <p>Миксины, которые принимают на вход параметры и выдают в зависимости от этого разный результат, следует использовать с осторожностью, как бы привлекательно они не выглядели. Они позволяют писать код быстрее, но если что-то пойдет не так, отлаживать такой код может быть довольно неудобно. Если вы только недавно познакомились с препроцессорами, от использования сложных конструкций лучше воздержаться.</p>
  </li>

  <li>
    <h3 id="variables">Переменные</h3>

    <p>Переменные удобно использовать для часто повторяющихся значений, например, для цветов. В отличие от HEX-значения цвета, название переменной можно вписать по памяти. Что проще запомнить и написать: <code>#ffd700</code> или <code>$gold</code>?</p>

    <p>Возможность удобно назвать неудобную кракозябру — одна из сильных сторон препроцессоров, только для переменных нужно выбирать удобные и запоминаемые имена.</p>
  </li>

  <li>
    <h3 id="mediaqueries">Медиавыражения</h3>

    <p>Препроцессоры позволяют вкладывать медиавыражения в блок стилей, что позволяет удобнее организовывать код. Например, так:</p>

<ul class="compare">
      <li class="compare__item compare__item--bad">
        <h4 class="compare__title">Плохо</h4>
<figure class="highlight">
<pre class="language-css"><code class="language-css">$bp-tablet: 660px;
$bp-desktop: 960px;

.header {
  padding: 20px;
  font-size: 20px;
}
.header A {
  text-transform: uppercase;
  color: crimson;
}

@media (min-width: $bp-tablet) {
  .header {
    padding: 30px;
  }
  .header A {
    color: orange;
  }
}

@media (min-width: $bp-desktop) {
  .header {
    padding: 40px;
  }
  .header A {
    color: gold;
  }
}</pre></code></figure>
      </li>
      <li class="compare__item compare__item--good">
        <h4 class="compare__title">Хорошо</h4>
<figure class="highlight">
<pre class="language-css"><code class="language-css">$bp-tablet: 660px;
$bp-desktop: 960px;

.header {
  padding: 20px;
  font-size: 20px;

  @media (min-width: $bp-tablet) {
    padding: 30px;
  }

  @media (min-width: $bp-desktop) {
    padding: 40px;
  }
}

.header A {
  text-transform: uppercase;
  color: crimson;

  @media (min-width: $bp-tablet) {
    color: orange;
  }

  @media (min-width: $bp-desktop) {
    color: gold;
  }
}</pre></code></figure>

      </li>
    </ul>

    <p>По примеру слева может быть не очень понятно в чём, собственно, проблема, потому что код короткий, но реальных проектах между элементом и медиавыражениями могут оказаться десятки строчек кода, и в этих условиях работать с кодом становится ощутимо неудобно.</p>

    <p>Если внутри медиавыражения окажется много кода, и оно перестанет помещаться в экран, придется всё время держать в голове с каким медиавыражением вы работаете в данный момент.</p>

    <p>Если же организовать код как в примере справа, все изменения стилей элемента будут лежать внутри самого элемента, и все точки изменений будут видны как на ладони. Это очень удобно.</p>

    <p>Правда, при таком подходе в скомпилированном слое получится много разрозненных медиавыражений для одних и тех же брикпойнтов, но эта проблема решается с помощью <a href="https://github.com/hail2u/node-css-mqpacker">css-mqpacker</a> — плагина для PostCSS.</p>

  </li>
</ol>




